* some thoughts
** Keys to achieve the desired behaviours:
- In a level, entering an expr and expecting the repl to evaluate it differently should be
  equivalent to running (f expr) in default evaluator
- evaluators for different levels are stored at meta cont, can't be changed, can only be generated via meaning. If one wants to change it, use delta and meaning at metalevel, and regenerate current level using the reified continuation, but with a different evaluator supplied to meaning
- 'lavender escape: for now just use it as part of eval built in, so only escapes if needed
- body of delta: body of delta will be evaluated using meta level's evaluator.
- evaluator can "change" in a begin. When a delta that regenerates current level with a different evaluator is called in a begin, all expressions afterwards are evaluated using the new evaluator
  -- this is still not certain and can change, since begin itself only exist in default evaluator,
     so whether this design decision makes sense needs to be reconsidered
     
** This means we need the following changes to Blond:
- change eval to apply evaluator, as well as lavender escape
- change meta cont representation, have extra evaluator, and all functions that messes with it
needs to be changed
- change meaning, should continue with the new evaluator after evaluating given expression
  -- or maybe better way is to decouple, have a special form (continue-with-eval e k f)
     that pushes current level to meta cont, start a new level that pushes e into k with f
     --- then we can call (meaning e r (cont-with-eval a k f) f)
- delta and gamma evaluates body using meta level's evaluator (defined level's evaluator for gamma and called level's evaluator for delta)
  This should mostly be straight forward, just add evaluator in addition to env and cont as arg
  so on one hand we have an extra value as argument (reified eval), on the other the meta level's
  evaluator also is needed to evaluate body
- begin: check how begin is implemented and use the most natural approach



-----

On escape and mixing:
should subexpressions of a level be non lavender even if we use 'lavender?
can have options
first is 'lavender, just make everything inside lavender
next is 'lavender-quazi, can break out from lavender
third is lavender-mix, we can write expressions whose outermost layer is lavender but inside
arguments are not

* other design decisions
lambdas and subr should either be forbidden to be used as evaluators, or use different conventions
for using them rather than application, or use default evaluator, or allow user to specify
an actual evaluator that they can use.

The issue here is, if the evaluator is f, and it is a lambda or subr, then trying to evaluate
any expression would lead to non termination. This is because evaluating an expression e is 
just calling f on e, so (f e). However e needs to be evaluated first before it gets passed as arg,
so we try to evaluate e again, ad infinitum.

Deciding the solution:
- forbidden: easy solution, but not necessary
- different conventions:
  -- weird conventions can get unintuitive, so it should be straight forward how they work
  -- syntax for defining lambdas can vary, but internally lambdas should have same behaviour
  -- treating a lambda as an fexpr is weird. We could have just used a reifier to define instead
  -- overall, seems not a good approach
- use default evaluator: good, but can we do more?
- allow users to customize what evaluator lambdas and subrs use:
  -- customizing how lambdas behave is unecessary since we could have just customized
     the (lambda (...) ...) form using different evaluators, such that a lambda form
     gets evaluated to, say a delta. However internally we are ok and wants to be consistent
  -- This seems rather strange to just wrap a layer of lambda on top of another evaluator.
     If we allow users to write custom evaluator ev for each lambda f, then evaluating an
     expression e is equivalent to running ev on e (evaluating e with ev), then evaluate
     body of f using ev, with e's result stored in environment
     --- we can achieve this by first defining ev as a delta, then 
         define the full evaluator as 
         (delta (e r k f) (let ((a (meaning e r k ev))) (meaning (lam a) r k default-eval)))
